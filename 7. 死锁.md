ps:本文有页内链接，请按住ctrl后左键点击，实现跳转

## 死锁

#### 产生与判断

##### 四个必要条件

互斥（一个资源只能由一个进程占用）；占用并等待；非抢占（资源不能被抢占）；循环等待；

##### 资源分配图判断死锁

有环可能死锁；无环无死锁；

#### 预防与避免

##### 预防死锁：确保以上四个必要条件中，至少一个必要条件不成立

###### 互斥（通常不能否定互斥）

###### 否定“占有并等待”

1，一次申请并获得所有资源；2，进程不占用资源的时候才能申请资源

上述两种方法缺点：资源利用率低，可能发生饥饿；

###### 否定“非抢占”

使用如下协议施行抢占：如果⼀个进程占有资源并申请另⼀个不能分配的资源，那么其现已分配的资源可被抢占；

实操：

> 资源可用:分配
>
> 资源不可用:
>
> >已分配给其他在等待额外资源的进程：抢占
> >
> >没有被其他等待额外资源的进程占有（也就是说这个资源还是被一个进程占有了，只是这个进程没有等待资源，在正常执行状态）：等待
> >
> ><img src="md_image\image-20220523150744877.png" alt="image-20220523150744877" style="zoom:67%;" />



###### 否定“循环等待”

采用有序资源使用法，为每个资源类型分配⼀个唯⼀的整数，每个进程按递增顺序申请资源



##### 避免死锁：利用事先得到进程申请资源和使用资源的额外信息，判断每当发生资源请求时是否会发生死锁

避免死锁指的是确保系统不进入不安全状态

###### 单个实例：资源分配图（改进版）

需求边：虚线，表示将来可能会申请，需求边变成申请边（虚线变实线）需要验证是否成环；

申请边、分配边：实线



###### 多个实例：银行家算法

背景：在银行中，客户申请贷款的数量是有限的，每个客户在第一次申请贷款时要声明完成该项目所需的最大资金量(即下面的max数组)，在满足所有贷款要求时，客户应及时归还。银行家在客户申请的贷款数量不超过自己拥有的最大值时(即下面的available vector)，都应尽量满足客户的需要。在这样的描述中，银行家就好比操作系统，资金就是资源，客户就相当于要申请资源的进程。

流程：每次请求资源的时候，先用资源请求算法，并且在资源请求算法中调用安全性检查，若通过安全性检查则允许此次请求。

**数据结构：**

available(一个长为m的int vector)，表示可分配的资源数量

max(一个n$\times$m的二维数组) ，max[i]表示线程i的资源最大需求数

allocation (一个n$\times$m的二维数组)，allocation[i]表示各个资源被分配给进程i多少个

(如下图实例1所示，p1-4都是进程，ABCD都是资源)

> <span id="example1">实例1</span>
>
> ```
>       Allocation　　　Max　　　Available
>  　　 ＡＢＣＤ　　  ＡＢＣＤ　　ＡＢＣＤ
>  P1   ００１４　　  ０６５６　　１５２０　
>  P2　 １４３２　　  １９４２　
>  P3　 １３５４　  　１３５６
>  P4 　１０００　　  １７５０
> ```



need（也是一个n$\times$m的二维数组），need[i]=max[i]-allocation[i]

(如下)

```
  NEED
 ＡＢＣＤ
 ０６４２　
 ０５１０
 ０００２
 ０７５０
```

finish（一个长为m的boolean vector），初始化全部为false



**1.安全性检查**

伪代码：

```pseudocode
safety-check:
    work=available;
    for all i, finish[i]=false;
    while(存在一个i, 满足Finish[i]==false且存在Need[i]<=work)
        work=work+allocation[i]
        finish[i]=true
    if for all i, finish[i]==true
        then the system is safe
    else 
    	not safe
```

或参考维基百科：

```pseudocode
safety-check:
    while (P != ∅) {
        found = FALSE;
        foreach (p ∈ P) {
            if (Mp − Cp ≤ A) {
                 /* p可以獲得他所需的資源。假設他得到資源後執行；執行終止，並釋放所擁有的資源。*/
                 A = A + Cp ;
                 P = P − {p};
                 found = TRUE;
            }
        }
        if (! found) return FAIL;
    }
    return OK;
```



> (原ppt的伪代码，此段可以不看)
>
> <img src="md_image\image-20220612204941729.png" alt="image-20220612204941729" style="zoom: 50%;" />
>
> 注意第三行的for all i do...，这里并不是表示要严格按照i=0,1,2,3,4的方式进行遍历；i的遍历顺序可以有多种，只要按照其中一种（e.g:在<a href="#example1">实例1</a>中2->3->4->1即为一个可行的顺序）遍历后，满足所有finish[i]=true即可。
>
> 因此我认为上述ppt中的伪代码并不准确，应当以维基的伪代码为准。



**2.资源请求算法**



<img src="md_image\image-20220612204955005.png" alt="image-20220612204955005" style="zoom:67%;" />



如果所有Process都可以完成并终止，则一个状态（如上述范例）被认为是安全的。由于系统无法知道什么时候一个过程将终止，或者之后它需要多少资源，系统假定所有进程将最终试图获取其声明的最大资源并在不久之后终止。



#### 死锁检测

死锁检测/恢复：类似safety check，但是略有不同

<img src="md_image\image-20220612213054178.png" alt="image-20220612213054178" style="zoom:67%;" />

证明：有序资源使用法情况下，不会产生循环等待；

#### 死锁恢复

##### 进程终止

1. 终止所有死锁进程 

2. ⼀次只终止⼀个进程直到取消死锁循环为止

##### 资源抢占

从进程中抢占资源给其他进程使用（<font color=red>需要防止饥饿</font>）



